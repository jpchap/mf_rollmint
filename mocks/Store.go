// Code generated by mockery v2.15.0. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	state "github.com/tendermint/tendermint/proto/tendermint/state"

	tenderminttypes "github.com/tendermint/tendermint/types"

	types "github.com/celestiaorg/rollmint/types"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// Height provides a mock function with given fields:
func (_m *Store) Height() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// LoadBlock provides a mock function with given fields: height
func (_m *Store) LoadBlock(height uint64) (*types.Block, error) {
	ret := _m.Called(height)

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func(uint64) *types.Block); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadBlockByHash provides a mock function with given fields: hash
func (_m *Store) LoadBlockByHash(hash [32]byte) (*types.Block, error) {
	ret := _m.Called(hash)

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func([32]byte) *types.Block); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([32]byte) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadBlockResponses provides a mock function with given fields: height
func (_m *Store) LoadBlockResponses(height uint64) (*state.ABCIResponses, error) {
	ret := _m.Called(height)

	var r0 *state.ABCIResponses
	if rf, ok := ret.Get(0).(func(uint64) *state.ABCIResponses); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.ABCIResponses)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadCommit provides a mock function with given fields: height
func (_m *Store) LoadCommit(height uint64) (*types.Commit, error) {
	ret := _m.Called(height)

	var r0 *types.Commit
	if rf, ok := ret.Get(0).(func(uint64) *types.Commit); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Commit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadCommitByHash provides a mock function with given fields: hash
func (_m *Store) LoadCommitByHash(hash [32]byte) (*types.Commit, error) {
	ret := _m.Called(hash)

	var r0 *types.Commit
	if rf, ok := ret.Get(0).(func([32]byte) *types.Commit); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Commit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([32]byte) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadState provides a mock function with given fields:
func (_m *Store) LoadState() (types.State, error) {
	ret := _m.Called()

	var r0 types.State
	if rf, ok := ret.Get(0).(func() types.State); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(types.State)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadValidators provides a mock function with given fields: height
func (_m *Store) LoadValidators(height uint64) (*tenderminttypes.ValidatorSet, error) {
	ret := _m.Called(height)

	var r0 *tenderminttypes.ValidatorSet
	if rf, ok := ret.Get(0).(func(uint64) *tenderminttypes.ValidatorSet); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tenderminttypes.ValidatorSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveBlock provides a mock function with given fields: block, commit
func (_m *Store) SaveBlock(block *types.Block, commit *types.Commit) error {
	ret := _m.Called(block, commit)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Block, *types.Commit) error); ok {
		r0 = rf(block, commit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveBlockResponses provides a mock function with given fields: height, responses
func (_m *Store) SaveBlockResponses(height uint64, responses *state.ABCIResponses) error {
	ret := _m.Called(height, responses)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, *state.ABCIResponses) error); ok {
		r0 = rf(height, responses)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveValidators provides a mock function with given fields: height, validatorSet
func (_m *Store) SaveValidators(height uint64, validatorSet *tenderminttypes.ValidatorSet) error {
	ret := _m.Called(height, validatorSet)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, *tenderminttypes.ValidatorSet) error); ok {
		r0 = rf(height, validatorSet)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetHeight provides a mock function with given fields: height
func (_m *Store) SetHeight(height uint64) {
	_m.Called(height)
}

// UpdateState provides a mock function with given fields: _a0
func (_m *Store) UpdateState(_a0 types.State) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.State) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewStore interface {
	mock.TestingT
	Cleanup(func())
}

// NewStore creates a new instance of Store. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewStore(t mockConstructorTestingTNewStore) *Store {
	mock := &Store{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
